const t=t=>{const e={};let o=0,i=!1;const l=[],r=(i,l,r)=>{let n=e[`${r?.key}`];n||(n={l:0,r:[]},e[`${r?.key}`]=n);const c=r?.limit&&n.l>=r.limit||o>=(t?.globalLimit||1),m=c&&t?.timeout?setTimeout((()=>{const t=new Error("timeout");t.code=1,l(t)}),t.timeout):void 0,u=()=>i((()=>{clearTimeout(m),s(r)}));c&&n.r.push([u,r?.index||0]),o++,n.l++,c||u()},s=t=>{const i=e[`${t?.key}`];i&&(0!==i.r.length&&i.r.sort(((t,e)=>t[1]-e[1])).shift()?.[0](t),i.l--),o--};return{wait:t=>new Promise(((e,o)=>{i?l.push((()=>{r(e,o,t)})):r(e,o,t)})),release:s,lock:()=>{i=!0},unlock:()=>{for(i=!1;l.length>0;){const t=l.shift();t&&t()}}}};export{t as Mutex};
